<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>repeto Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="install.html"><strong aria-hidden="true">1.</strong> Installing repeto</a></li><li class="chapter-item expanded "><a href="py/interface.html"><strong aria-hidden="true">2.</strong> Python interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="py/tutorial.html"><strong aria-hidden="true">2.1.</strong> Tutorial</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Algorithm</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Repeats prediction</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Matching optimization</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Development</li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> For developers</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">repeto Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-repeto"><a class="header" href="#installing-repeto">Installing <em>repeto</em></a></h1>
<p>You can install <strong>repeto</strong> in a few different ways, depending on your needs:</p>
<h3 id="rust-library"><a class="header" href="#rust-library">Rust library</a></h3>
<p>Currently, repeto isn't available as a package on <a href="https://crates.io">crates.io</a>. However, you can instruct Cargo to
depend on it via the GitHub repository. Here's how:</p>
<pre><code class="language-toml">repeto = { git = &quot;https://github.com/nucleohub/repeto&quot;, rev = &quot;e56c83d&quot; }
</code></pre>
<p>In this example, <code>rev</code> is the desired git commit hash. Note that the minimum supported version of Rust is 1.68, an
earlier versions may work but have not been tested.</p>
<h3 id="python-bindings"><a class="header" href="#python-bindings">Python bindings</a></h3>
<p>For Linux distributions, you can install pre-built Python 3.7 bindings for repeto directly using pip:</p>
<pre><code class="language-shell">python -m pip install repeto
</code></pre>
<p>If you're using a different platform or interpreter, pip will try to build repeto from the source code.
To do this, you'll need a working Rust/Cargo toolchain. You can find installation instructions for Rust
at <a href="https://www.rust-lang.org/tools/install">this</a> link. Note that the minimum supported Python version is 3.7.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-interface"><a class="header" href="#python-interface">Python interface</a></h1>
<p>Python bindings are the main way for most users to interact with the <strong>repeto</strong> library. These bindings are designed to
work seamlessly with Python's memory system, and they include the following features:</p>
<ul>
<li>All objects and fields are treated as pointers, following Python's conventions.</li>
<li>The bindings support pickling and unpickling, which allow users to serialize and deserialize objects.</li>
<li>The bindings also support type hints, which provide additional information about the types of objects and functions in
the library.</li>
</ul>
<p>One thing to keep in mind when using <code>repeto.optimize</code> function is that all input inverted repeats are copied into
native Rust types and then transformed back into Python classes. This means that any additional links to input repeats
will no longer be valid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-tutorial"><a class="header" href="#python-tutorial">Python tutorial</a></h1>
<p>Before you start, make sure you've installed the repeto Python bindings. You can find installation
instructions <a href="py/../install.html">here</a>.</p>
<p><strong>repeto</strong> is currently focused only on inverted DNA/RNA repeats (IRs), and there are two main functions you'll need to
know to get started: <code>repeto.predict</code> and <code>repeto.optimize</code>. <code>repeto.predict</code> is used to find IRs in a given sequence,
while <code>repeto.optimize</code> uses user-supplied scores to derive an optimal matching for the IRs (i.e., a valid RNA secondary
structure). You can find more details about the algorithm <a href="py/../algorithm.html">here</a>.</p>
<p>Here's a basic usage example:</p>
<pre><code class="language-python">import repeto

# Predict inverted repeats in the given sequence
sequence = &quot;AAAAATTTTTAAAAATTTT&quot;
irs, alignment_scores = repeto.predict(
    sequence.encode(&quot;ASCII&quot;),  # Target DNA/RNA sequence
    # IRs' thresholds
    min_score=5,  # Minimum alignment score
    min_matches_run=2,  # Minimum number of consecutive base pairs (e.g., min dsRNA/cruciform stem length)
)

# Customize repeats scores
scores = [x ** 2 for x in alignment_scores]

# Optimize inverted repeats matching
irs, total_score = repeto.optimize(irs, scores)
</code></pre>
<p>In this example, <code>sequence</code> is the target DNA/RNA sequence, and <code>min_score</code> and <code>min_matches_run</code> are thresholds for IRs
to report. The <code>scores</code> list is a user-supplied list of scores to use for optimizing the IRs.</p>
<h2 id="realistic-use-case"><a class="header" href="#realistic-use-case">Realistic Use Case</a></h2>
<p>Let's say we're studying an RNA-binding protein and want to check if its binding is co-localized with putative long
double-stranded RNAs (dsRNAs) formed by inverted repeats. Our colleagues have already performed an experiment, mapped
all
binding sites to the human genome, and provided us with a BED file containing their (stranded) coordinates. Our goal is
to
check for co-localization.</p>
<p>To do this, we will use several additional Python libraries that can be installed via pip:</p>
<pre><code class="language-shell">python -m pip install pybedtools, intervaltree, joblib
</code></pre>
<h3 id="group-binding-sites"><a class="header" href="#group-binding-sites">Group binding sites</a></h3>
<p>First, we need to group nearby binding sites together. This is done to speed up the downstream analysis
and avoid double processing of sequences derived from nearby binding sites:</p>
<pre><code class="language-python">import pybedtools
import os
from pybedtools import BedTool, Interval

MAX_ARMS_DISTANCE = 5_000  # hard-max distance between two arms of a dsRNA
SITES = &quot;data/binding-sites.bed&quot;  # file with binding sites
ASSEMBLY = &quot;data/assembly.fa&quot;  # indexed genome fasta

# Use pybedtools builtin chromsizes
# chrominfo = pybedtools.chromsizes(&quot;hg38&quot;)

# Or use fasta index to calculate them on the fly
assert os.path.exists(ASSEMBLY + &quot;.fai&quot;), &quot;Use samtools faidx to index genome fasta&quot;
with open(ASSEMBLY + &quot;.fai&quot;) as stream:
    lines = [x.split('\t') for x in stream.readlines()]
    chrominfo = {contig: (0, length) for contig, length, *_ in lines}

# Group sites within MAX_ARMS_GAP proximity
groups = BedTool(SITES) \
    .set_chromsizes(chrominfo) \
    .slop(b=MAX_ARMS_DISTANCE) \
    .sort() \
    .merge(s=True, c=6, o=&quot;distinct&quot;)

# fix the strand column
groups = BedTool([Interval(x.chrom, x.start, x.end, strand=x.fields[3]) for x in groups]).sort()
</code></pre>
<p>In this code, MAX_DISTANCE is the maximum distance between two arms of a dsRNA. Feel free to adjust this value,
but keep in mind that very long IRs (&gt;5 kbp) can fold back to form a dsRNA on a distance as long as 50 kbp.</p>
<h3 id="fetch-sequences"><a class="header" href="#fetch-sequences">Fetch sequences</a></h3>
<p>After grouping nearby binding sites, the next step is to fetch the genome sequences:</p>
<pre><code class="language-python">from Bio import SeqIO

# Fetch fasta
fasta = groups.sequence(fi=ASSEMBLY, s=True).seqfn

# Parse sequences &amp; preprocess
sequences = []
for group, seq in zip(groups, SeqIO.parse(fasta, format='fasta')):
    seq = str(seq.seq).upper()

    # Flip reverse complemented sequences for easier coordinates mapping later
    if group.strand == &quot;-&quot;:
        seq = seq[::-1]

    sequences.append((group, seq))
</code></pre>
<h3 id="predict--optimize-inverted-repeats"><a class="header" href="#predict--optimize-inverted-repeats">Predict &amp; Optimize inverted repeats</a></h3>
<p>Next, we'll search for inverted repeats that could have formed double-stranded RNAs(&gt;=50bp) sensed by the protein of
interest:</p>
<pre><code class="language-python">from collections import defaultdict
from typing import List, Tuple

import intervaltree
import repeto
from joblib import Parallel, delayed

MIN_DSRNA_SIZE = 30

# Build a simple genomic index of binding sites to filter predicted IRs
INDEX = defaultdict(lambda *args: intervaltree.IntervalTree())
for site in BedTool(SITES):
    INDEX[(site.chrom, site.strand)].addi(site.start, site.end, site)


# Function to predict IRs and &quot;optimize&quot; them
def job(interval: Interval, sequence: str) -&gt; Tuple[Interval, str, List[repeto.InvertedRepeat]]:
    # Predict all IRs in the given sequence
    irs, alnscores = repeto.predict(sequence.encode(&quot;ASCII&quot;), min_score=MIN_DSRNA_SIZE, min_matches_run=MIN_DSRNA_SIZE)

    # Transform IR coordinates from sequence-based to genome-based
    for ir in irs:
        ir.shift(interval.start)

    # Remove IRs that don't overlap binding sites on both &quot;sides&quot; (dsRNA stem arms)
    # Calculate optimization score as the alignment score + (number of bases overlapping binding sites) * 2
    filtered, index = [], INDEX[(interval.chrom, interval.strand)]
    for ir, score in zip(irs, alnscores):
        # Skip IRs with too large gap
        maxgap = max(segment.right.start - segment.left.end for segment in ir.segments)
        if maxgap &gt;= MAX_ARMS_DISTANCE:
            continue

        replicated = False
        for segment in ir.segments:
            # Calculate the number of base pairs in runs with length &gt;= MIN_DSRNA_SIZE
            # that overlap with binding sites for each stem arm
            arm_overlaps = []
            for arm in segment.left, segment.right:
                overlap_size = [x.overlap_size(arm.start, arm.end) for x in index.overlap(arm.start, arm.end)]
                arm_overlaps.append([size for size in overlap_size if size &gt;= MIN_DSRNA_SIZE])
            left, right = arm_overlaps

            # Keep the IR if at least some segment (dsRNA stem) overlaps with peaks on both sides (arms)
            replicated = replicated or len(left) &gt; 0 and len(right) &gt; 0

            # Update the score based on the number of overlapping base pairs
            score += sum(left) * 2 + sum(right) * 2
        if replicated:
            filtered.append((ir, score))

    if len(filtered) == 0:
        return interval, sequence, []

    # Find the optimal combination of inverted repeats (=data-supported dsRNAs)
    # Maximize the alignment score and the total length of binding sites explained by the IR * 2
    irs, scores = zip(*filtered)
    irs, _ = repeto.optimize(irs, scores)
    return interval, sequence, irs


# Apply the function to all sequences in parallel
results = Parallel(n_jobs=-1)(delayed(job)(i, s) for i, s in sequences)
results = [x for x in results if len(x[2]) &gt; 0]  # drop sequences without matched IRs
</code></pre>
<p>The code example above is the longest because <strong>repeto</strong> makes <strong>you</strong> responsible for creating meaningful scores. This
makes it as flexible as possible and allows you to explore any exotic weighing options.</p>
<h3 id="final-results"><a class="header" href="#final-results">Final results</a></h3>
<p>Getting back to the original question, let's check the number of binding sites explained by IRs:</p>
<pre><code class="language-python"># First let's save repeto results as BED12 file.
# This file can be also used to visualize results in a genome browser later
saveto = &quot;inverted-repeats.bed&quot;
with open(saveto, 'w') as stream:
    for window, _, irs in results:
        for ir in irs:
            stream.write(f&quot;{ir.to_bed12(contig=window.chrom, strand=window.strand)}\n&quot;)

irs = BedTool(saveto).sort().saveas(saveto)

# How many binding sites were explained by our putative dsRNAs?
sites = BedTool(SITES)
total_sites = len(sites)
intersection = sites.sort().intersect(irs, wa=True, u=True, split=True, s=True)
intersection = len(intersection)

print(f&quot;Total explained binding sites: {intersection} ({intersection / total_sites * 100: .2f}%)&quot;)
</code></pre>
<h3 id="concluding-remarks"><a class="header" href="#concluding-remarks">Concluding remarks</a></h3>
<p>Although the above example is a little bit synthetic, it should provide you with a solid ground on how to use repeto
in a real world project. Good luck!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
